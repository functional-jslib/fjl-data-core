{"version":3,"file":"fjl-data-core.js","sources":["../../src/functor/Functor.js","../../src/functor/Apply.js","../../src/functor/Applicative.js","../../src/functor/Bifunctor.js","../../src/monad/Monad.js","../../src/io/IO.js","../../src/maybe/Nothing.js","../../src/maybe/Just.js","../../src/maybe/Maybe.js","../../src/either/Either.js"],"sourcesContent":["/**\r\n * Functor class and associated operations.\r\n * Created by edlc on 12/9/16.\r\n * @module functor\r\n */\r\n\r\n/**\r\n * Always returns a functor;  If given value is not\r\n * a functor creates one from given value to it.\r\n * @function module:functor.toFunctor\r\n * @param x {{map: Function}|*} - Functor or any.\r\n * @returns {*}\r\n */\r\nexport const toFunctor = x => !x.map ? new Functor(x) : x;\r\n\r\n/**\r\n * Plain old functor class.\r\n * @class module:functor.Functor\r\n * @param value {*}\r\n * @property value {*}\r\n */\r\nexport default class Functor {\r\n\r\n    /**\r\n     * @constructor\r\n     * @param value {*}\r\n     */\r\n    constructor(value) {\r\n        this.value = value;\r\n    }\r\n\r\n    /**\r\n     * Extracts value of functor (same as monadic `join`).\r\n     * @method module:functor.Functor#valueOf\r\n     * @returns {*}\r\n     */\r\n    valueOf() {\r\n        return this.value;\r\n    }\r\n\r\n    /**\r\n     * Maps a function over contents of functor.\r\n     * @method module:functor.Functor#map\r\n     * @param fn {Function} - Function that takes one `any` and returns one `any`.\r\n     * @returns {Functor}\r\n     */\r\n    map(fn) {\r\n        return new this.constructor(fn(this.valueOf()));\r\n    }\r\n\r\n    /**\r\n     * Same as `#Functor.map`.\r\n     * @method module:functor.Functor#fmap\r\n     * @param fn {Function}\r\n     * @returns {Functor}\r\n     */\r\n    fmap (fn) {\r\n        return this.map(fn);\r\n    }\r\n}\r\n","/**\r\n * Contains `Applicative`'s `Apply` class (class that contains `ap` (a.k.a. `pure`) method).\r\n * Created by edlc on 12/9/16.\r\n * @memberOf module:functor\r\n */\r\n\r\nimport {toFunction} from 'fjl';\r\nimport Functor from './Functor';\r\n\r\n/**\r\n * Apply construct.\r\n * @class module:functor.Apply\r\n * @param fn {Function|*}\r\n * @property value {*}\r\n * @extends module:functor.Functor\r\n */\r\nexport default class Apply extends Functor {\r\n    /**\r\n     * Applicative apply operation - applies contained function over passed in functor.\r\n     * @method module:functor.Apply#ap\r\n     * @param x {Functor}\r\n     * @returns {Apply}\r\n     */\r\n    ap (x) {\r\n        return x.map(toFunction(this.valueOf()));\r\n    }\r\n}\r\n","/**\r\n * Created by edlc on 12/9/16.\r\n * Applicative class module.\r\n * @memberOf module:functor\r\n */\r\nimport Apply from './Apply';\r\n\r\n/**\r\n * @class module:functor.Applicative\r\n * @extends module:functor.Apply\r\n */\r\nexport default class Applicative extends Apply {\r\n    /**\r\n     * Constructs an applicative with given `value`.\r\n     * @method module:functor.Applicative.of\r\n     * @param value {*}\r\n     * @returns {Applicative}\r\n     * @static\r\n     */\r\n    static of (value) {\r\n        return new Applicative(value);\r\n    }\r\n\r\n    static liftA2 (fn, appA, appB) {\r\n        return appA.constructor.of(\r\n            fn(appA.valueOf(), appB.valueOf)\r\n        );\r\n    }\r\n\r\n    static apRight (appA, appB) {\r\n        return appB;\r\n    }\r\n\r\n    static apLeft (appA, appB) {\r\n        return appA;\r\n    }\r\n}\r\n\r\nexport const\r\n\r\n    pureApp = Applicative.of,\r\n\r\n    liftA2 = Applicative.liftA2,\r\n\r\n    apLeft = Applicative.apLeft,\r\n\r\n    apRight = Applicative.apRight\r\n\r\n;\r\n\r\n","/**\r\n * Created by edlc on 12/9/16.\r\n * @memberOf module:functor\r\n */\r\nimport Functor from './Functor';\r\n\r\n/**\r\n * Bifunctor class;  Mostly useful for eithers and/or maybes.\r\n * @class module:functor.Bifunctor\r\n * @param value1 {*}\r\n * @param value2 {*}\r\n * @property value {*}\r\n * @property value2 {*}\r\n * @extends module:functor.Functor\r\n */\r\nexport default class Bifunctor extends Functor {\r\n\r\n    /**\r\n     * @param value1 {*}\r\n     * @param value2 {*}\r\n     * @private\r\n     * @returns {Bifunctor}\r\n     */\r\n    constructor(value1, value2) {\r\n        super(value1);\r\n        this.value2 = value2;\r\n    }\r\n\r\n    /**\r\n     * Returns wrapped 'second' value.\r\n     * @method module:functor.Bifunctor#value2Of\r\n     * @returns {*}\r\n     */\r\n    value2Of() {\r\n        return this.value2;\r\n    }\r\n\r\n    /**\r\n     * Allows you to map over first 'contained' value.\r\n     * @method module:functor.Bifunctor#first\r\n     * @param fn {Function} - Unary operation.\r\n     * @returns {Bifunctor}\r\n     */\r\n    first (fn) {\r\n        return new this.constructor(fn(this.valueOf()), this.value2Of());\r\n    }\r\n\r\n    /**\r\n     * Allows you to map over second 'contained' value.\r\n     * @method module:functor.Bifunctor#second\r\n     * @param fn {Function} - Unary operation.\r\n     * @returns {Bifunctor}\r\n     */\r\n    second (fn) {\r\n        return new this.constructor(this.valueOf(), fn(this.value2Of()));\r\n    }\r\n\r\n    /**\r\n     * Allows you to map 2 functions over contained values - One function over each value.\r\n     * @method module:functor.Bifunctor#bimap\r\n     * @param fn1 {Function} - Unary op.\r\n     * @param fn2 {Function} - Unary op.\r\n     * @returns {Bifunctor}\r\n     */\r\n    bimap (fn1, fn2) {\r\n        return new this.constructor(\r\n            fn1(this.valueOf()),\r\n            fn2(this.value2Of())\r\n        );\r\n    }\r\n}\r\n","/**\r\n * Created by edlc on 12/9/16.\r\n * Contains basic `Monad` class and associated methods.\r\n * For 'what is a monad'/back-story\r\n * @see `Maybe` reference: [http://hackage.haskell.org/package/base-4.10.1.0/docs/Data-Maybe.html](http://hackage.haskell.org/package/base-4.10.1.0/docs/Data-Maybe.html)\r\n * @see `Either` reference: [http://hackage.haskell.org/package/base-4.10.1.0/docs/Data-Either.html](http://hackage.haskell.org/package/base-4.10.1.0/docs/Data-Either.html)\r\n * @module monad\r\n */\r\n\r\nimport {isset, curry, instanceOf, trampoline} from 'fjl';\r\nimport Applicative from '../functor/Applicative';\r\n\r\nexport const\r\n\r\n    /**\r\n     * Returns boolean indicating whether given value is an\r\n     * instance of monad or not.\r\n     * @function module:monad.isMonad\r\n     * @param value {*}\r\n     * @returns {boolean}\r\n     */\r\n    isMonad = value => value && value instanceof Monad,\r\n\r\n    /**\r\n     * Always returns a monad;  If given value is not\r\n     * a monad creates one using given value.\r\n     * @function module:monad.toMonad\r\n     * @param x {Monad|*} - Monad or any.\r\n     * @returns {*}\r\n     */\r\n    toMonad = x => !isMonad(x) ? new Monad(x) : x,\r\n\r\n    /**\r\n     * Calls `valueOf` on value (use for functional composition).\r\n     * @function module:monad.valueOf\r\n     * @param x {*}\r\n     * @returns {*}\r\n     */\r\n    valueOf = x => x.valueOf(),\r\n\r\n    /**\r\n     * Calls `valueOf` on given value.  Same as\r\n     * monadic `join` operation (extracts inner value of\r\n     * container/object).\r\n     * @function module:monad.join\r\n     * @param x {*}\r\n     * @returns {*}\r\n     */\r\n    join = valueOf,\r\n\r\n    /**\r\n     * Maps given function over given functor.\r\n     * @function module:monad.fmap\r\n     * @param fn {Function}\r\n     * @param x {Functor}\r\n     * @returns {Functor}\r\n     */\r\n    fmap = curry((fn, x) => x.map(fn)),\r\n\r\n    /**\r\n     * Applies function contained by applicative to contents of given functor.\r\n     * (Same as functional applicative `apply`).\r\n     * @function module:monad.ap\r\n     * @param applicative {Applicative}\r\n     * @param functor {Functor}\r\n     * @returns {Applicative}\r\n     */\r\n    ap = curry((applicative, functor) => applicative.ap(functor)),\r\n\r\n    /**\r\n     * Flat maps a function over given monad's contained value.\r\n     * @function module:monad.flatMap\r\n     * @param fn {Function}\r\n     * @param monad {Monad}\r\n     * @returns {Monad}\r\n     */\r\n    flatMap = curry((fn, monad) => monad.flatMap(fn)),\r\n\r\n    /**\r\n     * A recursive monad un-wrapper - Returns monad's unwrapped, inner-mostly, contained value (recursively).\r\n     * @function module:monad.getMonadUnWrapper\r\n     * @param Type {Function}\r\n     * @returns {Array.<*>} - [unWrapFunction, tailCallFuncName (used by `trampoline` @see module:fjl.trampoline)]\r\n     */\r\n    getMonadUnWrapper = Type => {\r\n        return [ function unWrapMonadByType(monad) {\r\n                return instanceOf(Type, monad) ?\r\n                    function trampolineCall() {\r\n                        return unWrapMonadByType(monad.valueOf());\r\n                    } :\r\n                    monad;\r\n            }, 'trampolineCall' ];\r\n    },\r\n\r\n    /**\r\n     * Unwraps monad by type.\r\n     * @function module:monad.unWrapMonadByType\r\n     * @param Type {Function}\r\n     * @param monad {Monad}\r\n     * @returns {*}\r\n     */\r\n    unWrapMonadByType = (Type, monad) => {\r\n        if (!isset(monad)) {\r\n            return monad;\r\n        }\r\n        const [unWrapper, tailCallName] = getMonadUnWrapper(Type),\r\n            unwrap = trampoline(unWrapper, tailCallName);\r\n        return unwrap(monad);\r\n    };\r\n\r\n/**\r\n * @class module:monad.Monad\r\n * @param x {*}\r\n * @property value {*}\r\n * @extends module:functor.Applicative\r\n */\r\nexport default class Monad extends Applicative {\r\n    /**\r\n     * Monadic join - Removes one layer of monadic structure from value.\r\n     * @memberOf module:monad.Monad\r\n     * @returns {*}\r\n     */\r\n    join () {\r\n        return this.valueOf();\r\n    }\r\n\r\n    /**\r\n     * Flat map operation.\r\n     * @memberOf module:monad.Monad\r\n     * @param fn {Function}\r\n     * @returns {Monad}\r\n     */\r\n    flatMap (fn) {\r\n        const out = unWrapMonadByType(this.constructor, fn(this.join()));\r\n        return this.constructor.of(out);\r\n    }\r\n\r\n    /**\r\n     * Same as `Monad.flatMap`.\r\n     * @memberOf module:monad.Monad\r\n     * @param fn {Function}\r\n     * @returns {Monad}\r\n     */\r\n    chain (fn) {\r\n        return this.flatMap(fn);\r\n    }\r\n\r\n    /**\r\n     * Same as `new Monad(...)` just in 'static' function\r\n     * format.\r\n     * @memberOf module:monad.Monad\r\n     * @static\r\n     * @param x {*}\r\n     * @returns {Monad}\r\n     */\r\n    static of (x) { return new Monad(x); }\r\n}\r\n","/**\r\n * Created by elydelacruz on 2/19/2017.\r\n * Io module - Contains `IO` class.\r\n * Fore more on io class\r\n * @see http://learnyouahaskell.com/input-and-output\r\n * @module io\r\n */\r\n\r\nimport Monad, {unWrapMonadByType} from '../monad/Monad';\r\nimport {compose, toFunction} from 'fjl';\r\n\r\n/**\r\n * @class io.IO\r\n * @param fn {Function} - Operation to contain within `IO`\r\n * @property `value` {*} - `IO` however wraps non-function values to `function` on construction.\r\n * @extends module:monad.Monad\r\n */\r\nexport default class IO extends Monad {\r\n    /**\r\n     * Unwraps an `IO`.\r\n     * @function module:io.IO.unWrapIO\r\n     * @static\r\n     * @param io {IO}\r\n     * @returns {*}\r\n     */\r\n    static unWrapIO (io) {\r\n        if (!IO.isIO(io)) { return io; }\r\n        return unWrapMonadByType(IO, io);\r\n    }\r\n\r\n    /**\r\n     * Applicative pure;  Same as `new IO(...)`.\r\n     * @function module:io.IO.of\r\n     * @static\r\n     * @param fn {Function} - Unary operation.\r\n     * @returns {IO}\r\n     */\r\n    static of(fn) {\r\n        return new IO(fn);\r\n    }\r\n\r\n    /**\r\n     * Checks for `IO`.\r\n     * @function module:io.IO.isIO\r\n     * @static\r\n     * @param x {*}.\r\n     * @returns {boolean}\r\n     */\r\n    static isIO (x) {\r\n        return x instanceof IO;\r\n    }\r\n\r\n    /**\r\n     * Performs io.\r\n     * @function module:io.IO.isIO\r\n     * @static\r\n     * @param io {IO}.\r\n     * @param args {...*} {IO}.\r\n     * @returns {boolean}\r\n     */\r\n    static do (io, ...args) {\r\n        const instance = !IO.isIO(io) ? new IO(io) : io;\r\n        return compose(\r\n            IO.of,\r\n            IO.unWrapIO\r\n        )(\r\n            toFunction(instance.join())(...args)\r\n        );\r\n    }\r\n\r\n    constructor(fn) {\r\n        super(toFunction(fn));\r\n    }\r\n\r\n    /**\r\n     * Maps incoming function onto contained, innermost, value\r\n     * and returns a new `IO` which will containe the result of calling incoming function on originally contained value - A.k.a - flat-map operation.\r\n     * @memberOf module:io.IO\r\n     * @param fn {Function} - Unary operation.\r\n     * @returns {IO}\r\n     */\r\n    flatMap (fn) {\r\n        return compose(\r\n            this.constructor.of,\r\n            IO.unWrapIO, fn,\r\n            IO.unWrapIO\r\n        )(\r\n            toFunction(this.join())()\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Maps incoming function on contained value and returns\r\n     * a new `IO` container containing result of unary operation (incoming-function's result).\r\n     * @memberOf module:io.IO\r\n     * @param fn {Function}\r\n     * @returns {IO}\r\n     */\r\n    map (fn) {\r\n        return compose(\r\n            this.constructor.of,\r\n            fn\r\n        )(\r\n            toFunction(this.valueOf())()\r\n        );\r\n    }\r\n}\r\n","let NothingSingleton;\r\n\r\n/**\r\n * Constructor and function for creating/fetching `Nothing`.\r\n * @note Nothing always returns a singleton instance of `Nothing` (whether calling `Nothing` with new or as a\r\n * function.\r\n * @function module:maybe.Nothing\r\n * @param [x=undefined]{*} - Ignored.\r\n * @returns {Nothing}\r\n * @constructor\r\n * @memberOf module:maybe\r\n */\r\nfunction Nothing (x = undefined) {\r\n    if (NothingSingleton) {\r\n        return NothingSingleton;\r\n    }\r\n    else if (!(this instanceof Nothing)) {\r\n        return new Nothing();\r\n    }\r\n    NothingSingleton = this;\r\n    Object.freeze(NothingSingleton);\r\n}\r\n\r\n// Documented further below\r\nconst\r\n\r\n    /**\r\n     * Checks for `Nothing`.\r\n     * @function module:maybe.isNothing\r\n     * @param x {*}\r\n     * @returns {boolean}\r\n     */\r\n    isNothing = x => x === NothingSingleton,\r\n\r\n    /**\r\n     * Returns `Nothing`.\r\n     * @function module:maybe.nothing\r\n     * @returns {Nothing}\r\n     */\r\n    nothing = () => new Nothing(),\r\n    returnThis = function (x) { return this; }\r\n    ;\r\n\r\n// Methods\r\n/**\r\n * Returns `Nothing`.\r\n * @method module:maybe.Nothing#valueOf\r\n * @returns {Nothing}\r\n */\r\nNothing.prototype.valueOf   = returnThis;\r\n/**\r\n * Returns `Nothing`.\r\n * @method module:maybe.Nothing#join\r\n * @returns {Nothing}\r\n */\r\nNothing.prototype.join      = returnThis;\r\n/**\r\n * Returns `Nothing`.\r\n * @method module:maybe.Nothing#map\r\n * @returns {Nothing}\r\n */\r\nNothing.prototype.map       = returnThis;\r\n/**\r\n * Returns `Nothing`.\r\n * @method module:maybe.Nothing#ap\r\n * @returns {Nothing}\r\n */\r\nNothing.prototype.ap        = returnThis;\r\n/**\r\n * Returns `Nothing`.\r\n * @method module:maybe.Nothing#flatMap\r\n * @returns {Nothing}\r\n */\r\nNothing.prototype.flatMap   = returnThis;\r\n\r\n// Set statics\r\n/**\r\n * Applicative `pure` - Same as `new Nothing()`, `Nothing()`, and `nothing()`.\r\n * @memberOf module:maybe.Nothing\r\n * @function module:maybe.Nothing.of\r\n * @static\r\n * @returns {Nothing}\r\n */\r\nNothing.of  = x => new Nothing();\r\n\r\n// Object.freeze makes properties on object immutable\r\n// @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze\r\n// Saves us from having to do the following (great!):\r\n// Object.defineProperties(Nothing, {\r\n//     of: {value: () => new Nothing(), enumerable: true},\r\n//     isNothing: {value: isNothing, enumerable: true}\r\n// });\r\nObject.freeze(Nothing);\r\n\r\nexport {isNothing, nothing};\r\n\r\nexport default Nothing;\r\n","/**\r\n * Contains `Just` constructor and associated methods.\r\n */\r\nimport Nothing, {isNothing} from './Nothing';\r\nimport Monad from '../monad/Monad';\r\nimport {isset} from 'fjl';\r\n\r\nexport const\r\n\r\n    /**\r\n     * Checks for `Just`.\r\n     * @function module:maybe.isJust\r\n     * @param x {*}\r\n     * @returns {boolean}\r\n     */\r\n    isJust = x => x instanceof Just,\r\n\r\n    /**\r\n     * Functional constructor (function that returns an instance) for `Just` -\r\n     * Same as `new Just(...)` (just shorter and can be used as a function).\r\n     * @function module:maybe.just\r\n     * @param x {Just|*}\r\n     * @returns {Just}\r\n     */\r\n    just = x => new Just(x),\r\n\r\n    /**\r\n     * Ensures `Just`\r\n     * @function module:maybe.toJust\r\n     * @param x {Just|*}\r\n     * @returns {Just}\r\n     */\r\n    toJust = x => isJust(x) ? x : just(x)\r\n\r\n;\r\n\r\n/**\r\n * @class maybe.Just\r\n * @param x {*}\r\n * @property value {*}\r\n * @extends module:monad.Monad\r\n */\r\nexport default class Just extends Monad {\r\n    /**\r\n     * Maps incoming function over contained value and\r\n     * returns result wrapped in `Just`.\r\n     * @method module:maybe.Just#map\r\n     * @param fn {Function} - Unary operation.\r\n     * @returns {Just|Nothing}\r\n     */\r\n    map (fn) {\r\n        const {constructor} = this,\r\n            value = this.valueOf();\r\n        return isset(value) && !isNothing(value) ? constructor.of(fn(value)) :\r\n            constructor.counterConstructor.of(value);\r\n    }\r\n\r\n    /**\r\n     * Applicative pure - Same as `new Just(...)`.\r\n     * @method module:maybe.Just.of\r\n     * @static\r\n     * @param x {*}\r\n     * @returns {Just}\r\n     */\r\n    static of (x) { return just(x); }\r\n}\r\n\r\n/**\r\n * @static\r\n * @member {Functor} module:maybe.Just.counterConstructor\r\n */\r\nJust.counterConstructor = Nothing;\r\n","/**\r\n * @module maybe\r\n */\r\nimport Just, {isJust, just} from './Just';\r\nimport Nothing, {isNothing, nothing} from './Nothing';\r\nimport {isset, curry, id, trampoline} from 'fjl';\r\nimport {getMonadUnWrapper} from '../monad/Monad';\r\n\r\nexport {Just, isJust, isNothing, Nothing, just, nothing};\r\n\r\nconst\r\n    /**\r\n     * @private\r\n     */\r\n    [justUnWrapper, justUnWrapperTailCallName] = getMonadUnWrapper(Just)\r\n;\r\n\r\nexport const\r\n    /**\r\n     * The maybe function takes a `replacement` value, a function (unary operation), and a Maybe value. If the Maybe value is `Nothing`, the function returns the `replacement` value. Otherwise, it applies the function to the value contained  by the `Just` and returns the result.\r\n     * @function module:maybe.maybe\r\n     * @param replacement {*}\r\n     * @param fn {Function} - Unary operation.\r\n     * @param maybeInst {(Nothing|Just|*)} - Maybe instance or non-maybe value.\r\n     * @returns {*}\r\n     */\r\n    maybe = curry((replacement, fn, maybeInst) => {\r\n        const subject = isset(maybeInst) && isMaybe(maybeInst) ? maybeInst.map(id) : nothing();\r\n        return isNothing(subject) ? replacement : subject.map(fn).join();\r\n    }),\r\n\r\n    /**\r\n     * Unwraps just (recursively).\r\n     * @function module:maybe.unWrapJust\r\n     * @param x {*} - Expected `Just`.\r\n     * @returns {*}\r\n     */\r\n    unWrapJust = trampoline(justUnWrapper, justUnWrapperTailCallName),\r\n\r\n    /**\r\n     * Unwraps maybe (recursively).\r\n     * @function module:maybe.unWrapMaybe\r\n     * @param x {*} - Expected `Maybe`.\r\n     * @returns {*}\r\n     */\r\n    unWrapMaybe = x => isNothing(x) ? nothing() : unWrapJust(x),\r\n\r\n    /**\r\n     * Equality operator for maybes.\r\n     * @function module:maybe.maybeEqual\r\n     * @param a {*} - Maybe 1.\r\n     * @param b {*} - Maybe 2.\r\n     * @returns {boolean}\r\n     */\r\n    maybeEqual = curry((a, b) => unWrapMaybe(a) === unWrapMaybe(b)),\r\n\r\n    /**\r\n     * Checks for maybe.\r\n     * @function module:maybe.isMaybe\r\n     *  @param x {*}.\r\n     * @returns {boolean}\r\n     */\r\n    isMaybe = x => isNothing(x) || isJust(x),\r\n\r\n    /**\r\n     * Creates maybe from value.\r\n     * @function module:maybe.toMaybe\r\n     * @param x {*}\r\n     * @returns {Maybe} - `Just` or `Nothing` based on value.\r\n     */\r\n    toMaybe = x => {\r\n        if (!isset(x)) {\r\n            return nothing();\r\n        }\r\n        return isMaybe(x) ? x : just(x);\r\n    }\r\n;\r\n","/**\r\n * Contains `Either` constructs (`Right`, `Left`,  `either` etc.) and associated operations.\r\n * Created by elyde on 12/10/2016.\r\n * @module either\r\n */\r\nimport {isset, curry, id, toFunction} from 'fjl';\r\nimport {Just} from '../maybe/Maybe';\r\nimport Monad from '../monad/Monad';\r\n\r\n/**\r\n * `Left` representation of `Either` construct.\r\n * @class module:either.Left\r\n * @param x {*}\r\n * @property value {*}\r\n * @extends module:monad.Monad\r\n */\r\nexport class Left extends Monad {\r\n    /**\r\n     * Same as `new Left(...)`.\r\n     * @method module:either.Left.of\r\n     * @static\r\n     * @param x {*}\r\n     * @returns {Left}\r\n     */\r\n    static of (x) { return new Left(x); }\r\n}\r\n\r\n/**\r\n * @class module:either.Right\r\n * @param x {*}\r\n * @property value {*}\r\n * @extends module:maybe.Just\r\n */\r\nexport class Right extends Just {\r\n    /**\r\n     * Maps a function over contained value and returns result wrapped.\r\n     * @method module:either.Right#map\r\n     * @param fn {Function} - Unary operation.\r\n     * @returns {Either}\r\n     */\r\n    map (fn) {\r\n        const value = this.valueOf();\r\n        if (isLeft(value)) {\r\n            return value;\r\n        }\r\n        else if (!isset(value)) {\r\n            return Left.of(\r\n                `TypeError: Cannot operate on \\`${value}\\`.`\r\n            );\r\n        }\r\n        return Right.of(fn(value));\r\n    }\r\n\r\n    /**\r\n     * Same as `new Right(...)`.\r\n     * @method module:either.Right.of\r\n     * @static\r\n     * @param x {*}\r\n     * @returns {Right}\r\n     */\r\n    static of (x) { return new Right(x); }\r\n}\r\n\r\nexport const\r\n\r\n    /**\r\n     * Returns a new `Left`\r\n     * @function module:either.left\r\n     * @param x {*}\r\n     * @returns {Left}\r\n     */\r\n    left = x => new Left(x),\r\n\r\n    /**\r\n     * Returns a `Right`.\r\n     * @function module:either.right\r\n     * @param x {*}\r\n     * @returns {Right}\r\n     */\r\n    right = x => new Right(x),\r\n\r\n    /**\r\n     * Checks for instance of `Right` constructor.\r\n     * @function module:either.isRight\r\n     * @param x {*}\r\n     * @returns {boolean}\r\n     */\r\n    isRight = x => x instanceof Right,\r\n\r\n    /**\r\n     * Checks for instance of `Left` constructor.\r\n     * @function module:either.isLeft\r\n     * @param x {*}\r\n     * @returns {boolean}\r\n     */\r\n    isLeft = x => x instanceof Left,\r\n\r\n    /**\r\n     * Returns a `Right` - if not a `Right` creates one from given, else returns given.\r\n     * @function module:either.toRight\r\n     * @param x {*}\r\n     * @returns {Right}\r\n     */\r\n    toRight = x => isRight(x) ? x : right(x),\r\n\r\n    /**\r\n     * Returns a `Left` - if not a `Left` creates one from given, else returns given.\r\n     * @function module:either.toLeft\r\n     * @param x {*}\r\n     * @returns {Left}\r\n     */\r\n    toLeft = x => isLeft(x) ? x : left(x),\r\n\r\n    /**\r\n     * Converts given to an either (`Right`|`Left`)\r\n     * @function module:either.toEither\r\n     * @param x {*}\r\n     * @returns {Left|Right}\r\n     */\r\n    toEither = x => isLeft(x) || isRight(x) ? x : right(x).map(id),\r\n\r\n    /**\r\n     * Calls matching callback on incoming `Either`'s type;  If is a `Left`\r\n     * (after mapping identity func on it) then calls left-callback and unwraps result\r\n     * else calls right-callback and does the same.  Think of it like a functional\r\n     * ternary statement (lol).\r\n     * @function module:either.either\r\n     * @param leftCallback {Function} - Mapped over value of `monad`'s identity.\r\n     * @param rightCallback {Function} - \"\".\r\n     * @param _either_ {Either|*}\r\n     * @return {*} - Value of unwrapped resulting value of `flatMap`ped, passed-in callback's on passed in monad.\r\n     * @example\r\n     * expect(\r\n         either(() => 404, () => 200, compose(right, right, right, right)(true))\r\n       ).toEqual(undefined);\r\n     */\r\n    either = curry((leftCallback, rightCallback, _either_) => {\r\n        const identity = toEither(_either_).flatMap(id),\r\n            out = isRight(_either_) ?\r\n                identity.flatMap(toFunction(rightCallback)) :\r\n                identity.flatMap(leftCallback)\r\n            ;\r\n        return isset(out) ? out.join() : out;\r\n    })\r\n\r\n;\r\n"],"names":["Functor","value","fn","constructor","valueOf","map","Apply","x","toFunction","Applicative","appA","appB","of","Bifunctor","value1","value2","value2Of","fn1","fn2","isMonad","Monad","join","fmap","curry","ap","applicative","functor","flatMap","monad","getMonadUnWrapper","Type","unWrapMonadByType","instanceOf","trampolineCall","isset","unWrapper","tailCallName","unwrap","trampoline","out","IO","io","isIO","instance","args","compose","unWrapIO","NothingSingleton","Nothing","Object","freeze","isNothing","nothing","returnThis","prototype","isJust","Just","just","counterConstructor","justUnWrapper","justUnWrapperTailCallName","maybe","replacement","maybeInst","subject","isMaybe","id","unWrapJust","unWrapMaybe","maybeEqual","a","b","toMaybe","Left","Right","isLeft","left","right","isRight","toRight","toLeft","toEither","either","leftCallback","rightCallback","_either_","identity"],"mappings":"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"}