/**! fjl-data-core.min.js 1.0.0 | License: BSD-3-Clause | md5checksum: 9aea2028ef5bc7338320c25817a62afa | Built-on: Thu Apr 05 2018 11:35:36 GMT-0400 (Eastern Daylight Time) **/import{curry,id,isFunction,isset}from"fjl";class Functor{constructor(t){this.value=t}valueOf(){return this.value}map(t){return new this.constructor(t(this.valueOf()))}fmap(t){return this.map(t)}}const toFunction=t=>isFunction(t)?t:()=>t,alwaysFunctor=t=>t.map?t:new Functor(t);class Apply extends Functor{ap(t){return t.map(toFunction(this.valueOf()))}}class Applicative extends Apply{static of(t){return new Applicative(t)}}const isMonad=t=>t instanceof Monad,valueOf=t=>t.valueOf(),join=t=>t.join(),fmap=curry((t,n)=>n.map(t)),ap=curry((t,n)=>t.ap(n)),flatMap=curry((t,n)=>n.flatMap(t));class Monad extends Applicative{join(){return this.valueOf()}flatMap(t){const n=t(this.join());return n instanceof this.constructor?n:this.constructor.of(n)}chain(t){return this.flatMap(t)}static of(t){return new Monad(t)}static isMonad(t){return isMonad(t)}}let NothingSingleton;function Nothing(){return NothingSingleton||(this instanceof Nothing?(NothingSingleton=this,void Object.freeze(NothingSingleton)):new Nothing)}const isNothing=t=>t===NothingSingleton,returnThis=function(){return this},{prototype:prototype}=Nothing;prototype.valueOf=returnThis,prototype.join=returnThis,prototype.map=returnThis,prototype.ap=returnThis,prototype.flatMap=returnThis,Nothing.of=(()=>new Nothing),Nothing.isNothing=isNothing,Object.freeze(Nothing);const isJust=t=>t instanceof Just;class Just extends Monad{map(t){const{constructor:n}=this,i=this.valueOf();return isset(i)&&!isNothing(i)?n.of(t(i)):n.counterConstructor.of(i)}static of(t){return new Just(t)}static isJust(t){return isJust(t)}}Just.counterConstructor=Nothing;const maybe=curry((t,n,i)=>{const o=isset(i)&&isMaybe(i)?i.map(id):Nothing.of();return isNothing(o)?t:o.map(n).join()}),isMaybe=t=>isNothing(t)||isJust(t);class Left extends Monad{static of(t){return new Left(t)}}class Right extends Just{map(t){const n=this.valueOf();return isLeft(n)?n:isset(n)?Right.of(t(n)):Left.of("TypeError: Cannot operate on `null` and/or `undefined`.  "+`Value given \`${n}\`.`)}static of(t){return new Right(t)}}const isRight=t=>t instanceof Right,isLeft=t=>t instanceof Left,either=curry((t,n,i)=>{const o=alwaysFunctor(i).map(id);switch(o.constructor){case Left:return o.map(toFunction(t)).join();case Right:return o.map(toFunction(n)).join();default:return Left.of(i).map(t).join()}});export{isMonad,valueOf,join,fmap,ap,flatMap,Just,isJust,isNothing,Nothing,maybe,isMaybe,isRight,isLeft,either,Left,Right,toFunction,alwaysFunctor};