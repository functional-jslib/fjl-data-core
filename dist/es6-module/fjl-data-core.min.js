/**! fjl-data-core.min.js 1.0.0 | License: BSD-3-Clause | md5checksum: b37e19a04687a51040588280f82505e7 | Built-on: Fri Apr 06 2018 06:17:18 GMT-0400 (Eastern Daylight Time) **/import{apply,curry,id,instanceOf,isFunction,isset}from"fjl";class Functor{constructor(t){this.value=t}valueOf(){return this.value}map(t){return new this.constructor(t(this.valueOf()))}fmap(t){return this.map(t)}}const toFunction=t=>isFunction(t)?t:()=>t,alwaysFunctor=t=>t.map?t:new Functor(t);class Apply extends Functor{ap(t){return t.map(toFunction(this.valueOf()))}}class Applicative extends Apply{static of(t){return new Applicative(t)}}const isMonad=t=>t instanceof Monad,valueOf=t=>t.valueOf(),join=t=>t.join(),fmap=curry((t,n)=>n.map(t)),ap=curry((t,n)=>t.ap(n)),flatMap=curry((t,n)=>n.flatMap(t)),getMonadUnWrapper=t=>{const n=instanceOf(t);return function t(o){return n(o)?function(){return t(o.valueOf())}:o}},trampoline=t=>(...n)=>{let o=apply(t,n);for(;isset(o)&&"trampolineCall"===o.name&&isFunction(o);)o=o();return o};class Monad extends Applicative{static unWrapMonadByType(t,n){if(!isset(n))return n;return trampoline(getMonadUnWrapper(t))(n)}join(){return Monad.unWrapMonadByType(this.constructor,this)}flatMap(t){const n=Monad.unWrapMonadByType(this.constructor,t(this.join()));return this.constructor.of(n)}chain(t){return this.flatMap(t)}static of(t){return new Monad(t)}static isMonad(t){return isMonad(t)}}let NothingSingleton;function Nothing(){return NothingSingleton||(this instanceof Nothing?(NothingSingleton=this,void Object.freeze(NothingSingleton)):new Nothing)}const isNothing=t=>t===NothingSingleton,returnThis=function(){return this},{prototype:prototype}=Nothing;prototype.valueOf=returnThis,prototype.join=returnThis,prototype.map=returnThis,prototype.ap=returnThis,prototype.flatMap=returnThis,Nothing.of=(()=>new Nothing),Nothing.isNothing=isNothing,Object.freeze(Nothing);const isJust=t=>t instanceof Just;class Just extends Monad{map(t){const{constructor:n}=this,o=this.valueOf();return isset(o)&&!isNothing(o)?n.of(t(o)):n.counterConstructor.of(o)}static of(t){return new Just(t)}static isJust(t){return isJust(t)}}Just.counterConstructor=Nothing;const maybe=curry((t,n,o)=>{const i=isset(o)&&isMaybe(o)?o.map(id):Nothing.of();return isNothing(i)?t:i.map(n).join()}),isMaybe=t=>isNothing(t)||isJust(t);class Left extends Monad{static of(t){return new Left(t)}}class Right extends Just{map(t){const n=this.valueOf();return isLeft(n)?n:isset(n)?Right.of(t(n)):Left.of("TypeError: Cannot operate on `null` and/or `undefined`.  "+`Value given \`${n}\`.`)}static of(t){return new Right(t)}}const isRight=t=>t instanceof Right,isLeft=t=>t instanceof Left,either=curry((t,n,o)=>{const i=alwaysFunctor(o).map(id);switch(i.constructor){case Left:return i.map(toFunction(t)).join();case Right:return i.map(toFunction(n)).join();default:return Left.of(o).map(t).join()}});export{isMonad,valueOf,join,fmap,ap,flatMap,getMonadUnWrapper,trampoline,Just,isJust,isNothing,Nothing,maybe,isMaybe,isRight,isLeft,either,Left,Right,toFunction,alwaysFunctor};